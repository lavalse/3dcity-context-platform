"""
SQL Generator service.

Two modes:
  - LLM mode:         ANTHROPIC_API_KEY is set → calls Claude API
  - Placeholder mode: no API key → keyword-based rule matching for testing
"""

from app.config import get_settings
from app.services.schema_context import get_system_prompt

# ---------------------------------------------------------------------------
# LLM mode (Claude API)
# ---------------------------------------------------------------------------

async def _generate_with_llm(question: str) -> tuple[str, str]:
    """Call Claude API and return (sql, explanation)."""
    import anthropic

    client = anthropic.AsyncAnthropic(api_key=get_settings().anthropic_api_key)
    system = get_system_prompt()

    message = await client.messages.create(
        model="claude-opus-4-5",
        max_tokens=1024,
        system=system,
        messages=[{"role": "user", "content": question}],
    )
    sql = message.content[0].text.strip()
    explanation = f"Generated by Claude API for: {question}"
    return sql, explanation


# ---------------------------------------------------------------------------
# Placeholder mode — keyword rules for development/testing
# ---------------------------------------------------------------------------

_PLACEHOLDER_RULES: list[tuple[list[str], str, str]] = [
    (
        ["how many", "何棟", "数は", "count", "total"],
        """SELECT COUNT(*) AS total_buildings
FROM citydb.building b
WHERE b.building_root_id = b.id""",
        "Counting all top-level buildings in Taito-ku",
    ),
    (
        ["residential", "住宅", "apartment", "共同住宅", "マンション"],
        """SELECT COUNT(*) AS residential_buildings
FROM citydb.building b
WHERE b.building_root_id = b.id
  AND b.usage IN ('411', '412', '413', '414', '415')""",
        "Counting buildings with residential usage codes (411–415)",
    ),
    (
        ["commercial", "商業", "office", "業務", "店舗"],
        """SELECT COUNT(*) AS commercial_buildings
FROM citydb.building b
WHERE b.building_root_id = b.id
  AND b.usage IN ('401', '402', '403', '404', '413', '414')""",
        "Counting buildings with commercial/retail usage codes",
    ),
    (
        ["public", "government", "官公庁", "school", "hospital", "文教", "福祉"],
        """SELECT COUNT(*) AS public_buildings
FROM citydb.building b
WHERE b.building_root_id = b.id
  AND b.usage IN ('421', '422')""",
        "Counting public/government/education/welfare buildings",
    ),
    (
        ["tallest", "highest", "最も高い", "top 10", "top10", "top ten"],
        """SELECT co.gmlid,
       b.measured_height AS height_m,
       b.storeys_above_ground AS floors,
       b.usage
FROM citydb.building b
JOIN citydb.cityobject co ON co.id = b.id
WHERE b.building_root_id = b.id
  AND b.measured_height > 0
ORDER BY b.measured_height DESC
LIMIT 10""",
        "Top 10 tallest buildings by measured height",
    ),
    (
        ["tall building", "高さ", "height over", "over.*meter", "31m", "31 m"],
        """SELECT COUNT(*) AS buildings_over_31m
FROM citydb.building b
WHERE b.building_root_id = b.id
  AND b.measured_height > 31""",
        "Counting buildings taller than 31 meters (high-rise threshold in Japan)",
    ),
    (
        ["height distribution", "高さ分布", "floor distribution", "distribution"],
        """SELECT
    CASE
        WHEN b.measured_height <= 0  THEN '不明 (no data)'
        WHEN b.measured_height < 10  THEN '< 10m (1-3F)'
        WHEN b.measured_height < 20  THEN '10-20m (4-6F)'
        WHEN b.measured_height < 31  THEN '20-31m (7-10F)'
        WHEN b.measured_height < 60  THEN '31-60m (mid-rise)'
        ELSE '>= 60m (high-rise)'
    END AS height_range,
    COUNT(*) AS count
FROM citydb.building b
WHERE b.building_root_id = b.id
GROUP BY height_range
ORDER BY MIN(b.measured_height)""",
        "Building height distribution in Taito-ku",
    ),
    (
        ["usage", "用途", "by type", "breakdown", "種別"],
        """SELECT
    b.usage AS code,
    CASE b.usage
        WHEN '401' THEN '業務施設'    WHEN '402' THEN '商業施設'
        WHEN '403' THEN '宿泊施設'    WHEN '404' THEN '商業系複合施設'
        WHEN '411' THEN '住宅'        WHEN '412' THEN '共同住宅'
        WHEN '413' THEN '店舗等併用住宅' WHEN '414' THEN '店舗等併用共同住宅'
        WHEN '415' THEN '作業所併用住宅' WHEN '421' THEN '官公庁施設'
        WHEN '422' THEN '文教厚生施設' WHEN '431' THEN '運輸倉庫施設'
        WHEN '441' THEN '工場'        WHEN '454' THEN 'その他'
        WHEN '461' THEN '不明'        ELSE b.usage
    END AS usage_label,
    COUNT(*) AS count
FROM citydb.building b
WHERE b.building_root_id = b.id
GROUP BY b.usage
ORDER BY count DESC""",
        "Building count breakdown by usage type",
    ),
    (
        ["floor", "階", "storey", "story", "stories"],
        """SELECT
    CASE
        WHEN b.storeys_above_ground = 9999 THEN '不明'
        WHEN b.storeys_above_ground = 1    THEN '1階'
        WHEN b.storeys_above_ground = 2    THEN '2階'
        WHEN b.storeys_above_ground = 3    THEN '3階'
        WHEN b.storeys_above_ground BETWEEN 4 AND 5  THEN '4-5階'
        WHEN b.storeys_above_ground BETWEEN 6 AND 10 THEN '6-10階'
        ELSE '11階以上'
    END AS floor_range,
    COUNT(*) AS count
FROM citydb.building b
WHERE b.building_root_id = b.id
GROUP BY floor_range
ORDER BY MIN(b.storeys_above_ground)""",
        "Building count by number of floors",
    ),
    (
        ["flood", "洪水", "water", "浸水", "inundation"],
        """SELECT COUNT(*) AS buildings_near_flood_zone
FROM citydb.building b
JOIN citydb.cityobject b_co ON b_co.id = b.id
WHERE b.building_root_id = b.id
  AND EXISTS (
    SELECT 1 FROM citydb.cityobject fld_co
    WHERE fld_co.objectclass_id = 9
      AND b_co.envelope && fld_co.envelope
  )""",
        "Counting buildings whose bounding box overlaps with flood zone areas (WaterBody)",
    ),
]


def _placeholder_generate(question: str) -> tuple[str, str]:
    q = question.lower()
    # Score each rule by number of matching keywords — pick the best match
    best_score, best_sql, best_explanation = 0, None, None
    for keywords, sql, explanation in _PLACEHOLDER_RULES:
        score = sum(1 for kw in keywords if kw in q)
        if score >= best_score:
            best_score, best_sql, best_explanation = score, sql, explanation
    if best_sql:
        return best_sql, best_explanation

    # Default: show sample buildings
    return (
        """SELECT co.gmlid,
       b.measured_height AS height_m,
       b.storeys_above_ground AS floors,
       b.usage
FROM citydb.building b
JOIN citydb.cityobject co ON co.id = b.id
WHERE b.building_root_id = b.id
  AND b.measured_height > 0
ORDER BY b.measured_height DESC
LIMIT 20""",
        "No specific pattern matched — showing top 20 buildings by height as a default.",
    )


# ---------------------------------------------------------------------------
# Public interface
# ---------------------------------------------------------------------------

async def generate_sql(question: str) -> dict:
    """
    Generate SQL from a natural language question.
    Returns: {sql, explanation, mode}
    """
    settings = get_settings()

    if settings.use_llm:
        sql, explanation = await _generate_with_llm(question)
        mode = "llm"
    else:
        sql, explanation = _placeholder_generate(question)
        mode = "placeholder"

    return {"sql": sql, "explanation": explanation, "mode": mode}
